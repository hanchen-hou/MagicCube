package com.hunter.magic_cube.model_factory;

import com.hunter.magic_cube.model.Cube;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 *
 * @author Hunter
 */
public class PocketCubeFactory {

    static final public int POCKET_CUBE_TILE_NUMBER = 24;

    static public Cube createPocketCube(String tilesInString, int numberOfRotations) {
        if (tilesInString.length() != POCKET_CUBE_TILE_NUMBER) {
            throw new RuntimeException("A pocket cube only has 24 tiles.");
        }

        return new Cube(tilesInString, numberOfRotations);
    }

    static public Cube createPocketCube(double[] tiles, int numberOfRotations) {
        if (tiles.length != POCKET_CUBE_TILE_NUMBER) {
            throw new RuntimeException("A pocket cube only has 24 tiles.");
        }

        return new Cube(tiles, numberOfRotations);
    }

    static public Cube createSolvedPocketCube() {
        double[] tiles = new double[POCKET_CUBE_TILE_NUMBER];

        int surfaceNumber = 6;
        int tileNumberPerSurface = 4;
        for (int i = 0; i < surfaceNumber; i++) {
            for (int j = 0; j < tileNumberPerSurface; j++) {
                tiles[j + i * tileNumberPerSurface] = i;
            }
        }

        return PocketCubeFactory.createPocketCube(tiles, 0);
    }
    
    
    /**
     * Used to convert a cube state to a standard cube state which can be used in the database.
     * All states in our database are generated by rotating Front, Right and Up, so the bottom back cornor is never moved.
     * By using the three colors of this unmoved block, we can get the other three colors
     * 
     * In more specific, the three colors from this unmoved block are at indices 7, 19 and 22
     * tiles[7] => Left color
     * tiles[19] => Bottom color
     * tiles[22] => Back color
     * Note, 7, 19, 22 form a corner.
     * Then, Left and Bottom color tell us the Front color
     * Left and Back color tell us the Up color
     * Back and Bottom color tell us the Right color
     * Last step, replace these colors to 0~5 to form a standard state
     * 
     * @param c A cube state. This state maybe not a standard state. e.g. it uses a different set of numbers to represent colors.
     * @return A standardize cube state
     */
    static public Cube standardizePocketCube(Cube c) {
        double[] tiles = c.getTiles();
        if (tiles.length != POCKET_CUBE_TILE_NUMBER) {
            throw new RuntimeException("A pocket cube only has 24 tiles.");
        }

        // 8 corners
        List<List<Double>> corners = new ArrayList<>();
        corners.add(Arrays.asList(tiles[0], tiles[5], tiles[11]));
        corners.add(Arrays.asList(tiles[1], tiles[10], tiles[12]));
        corners.add(Arrays.asList(tiles[2], tiles[15], tiles[17]));
        corners.add(Arrays.asList(tiles[3], tiles[6], tiles[16]));
        corners.add(Arrays.asList(tiles[4], tiles[8], tiles[21]));
        corners.add(Arrays.asList(tiles[7], tiles[19], tiles[22]));
        corners.add(Arrays.asList(tiles[9], tiles[13], tiles[20]));
        corners.add(Arrays.asList(tiles[14], tiles[18], tiles[23]));

        double[] colors = {0, 0, 0, 0, 0, 0};
        colors[1] = tiles[7]; // Left color
        colors[4] = tiles[19]; // Bottom color
        colors[5] = tiles[22]; // Back color

        for (var corner : corners) {
            // use colors of Left and Bottom to find Front color
            if (corner.contains(colors[1]) && corner.contains(colors[4]) && !corner.contains(colors[5])) {
                colors[0] = corner.stream().filter(tile -> !tile.equals(colors[1]) && !tile.equals(colors[4])).toArray(Double[]::new)[0];
            }
            // use colors of Left and Back to find Up color
            if (corner.contains(colors[1]) && corner.contains(colors[5]) && !corner.contains(colors[4])) {
                colors[2] = corner.stream().filter(tile -> !tile.equals(colors[1]) && !tile.equals(colors[5])).toArray(Double[]::new)[0];
            }
            // use colors of Bottom and Back to find Right color
            if (corner.contains(colors[4]) && corner.contains(colors[5]) && !corner.contains(colors[1])) {
                colors[3] = corner.stream().filter(tile -> !tile.equals(colors[4]) && !tile.equals(colors[5])).toArray(Double[]::new)[0];
            }
        }
        
        double[] newTiles = new double[24];
        for(int i = 0; i < tiles.length; i++){
            if(tiles[i] == colors[0]) newTiles[i] = 0;
            else if(tiles[i] == colors[1]) newTiles[i] = 1;
            else if(tiles[i] == colors[2]) newTiles[i] = 2;
            else if(tiles[i] == colors[3]) newTiles[i] = 3;
            else if(tiles[i] == colors[4]) newTiles[i] = 4;
            else if(tiles[i] == colors[5]) newTiles[i] = 5;
            else throw new RuntimeException("Invalid Cube");
        }

        return PocketCubeFactory.createPocketCube(newTiles, c.getNumberOfRotations());
    }
}
